{"ast":null,"code":"function convertObjectToURLInit(init) {\n  return Object.keys(init).reduce((memo, key) => {\n    const value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n  }, []);\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\n\n\nexport function createSearchParams() {\n  let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  const inputIsReadyForInstantiation = typeof init === 'string' || Array.isArray(init) || init instanceof URLSearchParams;\n  return new URLSearchParams(inputIsReadyForInstantiation ? init : convertObjectToURLInit(init));\n}\nexport function getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  const searchParams = createSearchParams(locationSearch);\n\n  if (defaultSearchParams) {\n    for (let key of defaultSearchParams.keys()) {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach(value => {\n          searchParams.append(key, value);\n        });\n      }\n    }\n  }\n\n  return searchParams;\n}","map":{"version":3,"mappings":"AAQA,SAASA,sBAAT,CAAgCC,IAAhC,EAAuE;EACrE,OAAOC,MAAM,CAACC,IAAP,CAAYF,IAAZ,EAAkBG,MAAlB,CAA8C,CAACC,IAAD,EAAOC,GAAP,KAAc;IACjE,MAAMC,KAAK,GAAGN,IAAI,CAACK,GAAD,CAAlB;IACA,OAAOD,IAAI,CAACG,MAAL,CACLC,KAAK,CAACC,OAAN,CAAcH,KAAd,IAAuBA,KAAK,CAACI,GAAN,CAAWC,CAAD,IAAO,CAACN,GAAD,EAAMM,CAAN,CAAjB,CAAvB,GAAoD,CAAC,CAACN,GAAD,EAAMC,KAAN,CAAD,CAD/C,CAAP;EAGD,CALM,EAKJ,EALI,CAAP;AAMD;AAED;;;;;;;;;;;;;;;;;;;;;;;AAqBA,OAAM,SAAUM,kBAAV,GAC0B;EAAA,IAA9BZ,IAA8B,uEAAF,EAAE;EAE9B,MAAMa,4BAA4B,GAAG,OAAOb,IAAP,KAAgB,QAAhB,IACnCQ,KAAK,CAACC,OAAN,CAAcT,IAAd,CADmC,IAEnCA,IAAI,YAAYc,eAFlB;EAGA,OAAO,IAAIA,eAAJ,CAAoBD,4BAA4B,GAAGb,IAAH,GAAUD,sBAAsB,CAACC,IAAD,CAAhF,CAAP;AACD;AAED,OAAM,SAAUe,0BAAV,CACJC,cADI,EAEJC,mBAFI,EAEuC;EAE3C,MAAMC,YAAY,GAAGN,kBAAkB,CAACI,cAAD,CAAvC;;EAEA,IAAIC,mBAAJ,EAAyB;IACvB,KAAK,IAAIZ,GAAT,IAAgBY,mBAAmB,CAACf,IAApB,EAAhB,EAA4C;MAC1C,IAAI,CAACgB,YAAY,CAACC,GAAb,CAAiBd,GAAjB,CAAL,EAA4B;QAC1BY,mBAAmB,CAACG,MAApB,CAA2Bf,GAA3B,EAAgCgB,OAAhC,CAAyCf,KAAD,IAAU;UAChDY,YAAY,CAACI,MAAb,CAAoBjB,GAApB,EAAyBC,KAAzB;QACD,CAFD;MAGD;IACF;EACF;;EAED,OAAOY,YAAP;AACD","names":["convertObjectToURLInit","init","Object","keys","reduce","memo","key","value","concat","Array","isArray","map","v","createSearchParams","inputIsReadyForInstantiation","URLSearchParams","getSearchParamsForLocation","locationSearch","defaultSearchParams","searchParams","has","getAll","forEach","append"],"sources":["C:\\Users\\nasti\\Desktop\\VK\\ForestEm\\Forest\\node_modules\\@vkontakte\\vk-mini-apps-router\\src\\utils\\createSearchParams.ts"],"sourcesContent":["export type ParamKeyValuePair = [string, string];\n\nexport type URLSearchParamsInit =\n  | string\n  | ParamKeyValuePair[]\n  | Record<string, string | string[]>\n  | URLSearchParams;\n\nfunction convertObjectToURLInit(init: Record<string, string | string[]>) {\n  return Object.keys(init).reduce<ParamKeyValuePair[]>((memo, key) => {\n    const value = init[key];\n    return memo.concat(\n      Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]],\n    );\n  }, []);\n}\n\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nexport function createSearchParams(\n  init: URLSearchParamsInit = ''\n): URLSearchParams {\n  const inputIsReadyForInstantiation = typeof init === 'string' ||\n    Array.isArray(init) ||\n    init instanceof URLSearchParams;\n  return new URLSearchParams(inputIsReadyForInstantiation ? init : convertObjectToURLInit(init));\n}\n\nexport function getSearchParamsForLocation(\n  locationSearch: string,\n  defaultSearchParams: URLSearchParams | null\n) {\n  const searchParams = createSearchParams(locationSearch);\n\n  if (defaultSearchParams) {\n    for (let key of defaultSearchParams.keys()) {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    }\n  }\n\n  return searchParams;\n}\n"]},"metadata":{},"sourceType":"module"}