{"ast":null,"code":"import { Action, createPath, UNSAFE_invariant as invariant } from '@remix-run/router';\nimport { createLocation } from './createLocation';\nimport { getHistoryState } from './getHistoryState';\nconst PopStateEventType = 'popstate';\n/* eslint-disable @typescript-eslint/no-use-before-define */\n\nexport function getUrlBasedHistory(getLocation, createHref, validateLocation) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    window = document.defaultView,\n    v5Compat = false\n  } = options;\n  const globalHistory = window.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex(); // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state,\n      idx: index\n    }, '');\n  }\n\n  function getIndex() {\n    const state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n\n  function handlePop() {\n    action = Action.Pop;\n    const nextIndex = getIndex(); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n    const delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n\n  function push(to, state) {\n    action = Action.Push;\n    const location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    const historyState = getHistoryState(location, index);\n    const url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/\n\n    try {\n      globalHistory.pushState(historyState, '', url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, const that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === 'DataCloneError') {\n        throw error;\n      } // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n\n\n      window.location.assign(url);\n    }\n\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n\n  function replace(to, state) {\n    action = Action.Replace;\n    const location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    const historyState = getHistoryState(location, index);\n    const url = history.createHref(location);\n    globalHistory.replaceState(historyState, '', url);\n\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n\n  function createURL(to) {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    const base = window.location.origin !== 'null' ? window.location.origin : window.location.href;\n    const href = typeof to === 'string' ? to : createPath(to);\n    invariant(base, `No window.location.(origin|href) available to create URL for href: ${href}`);\n    return new URL(href, base);\n  }\n\n  const history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n\n    listen(fn) {\n      if (listener) {\n        throw new Error('A history only accepts one active listener');\n      }\n\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n\n    createHref(to) {\n      return createHref(window, to);\n    },\n\n    createURL,\n\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      const url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n\n    push,\n    replace,\n\n    go(n) {\n      return globalHistory.go(n);\n    }\n\n  };\n  return history;\n}","map":{"version":3,"mappings":"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","names":["Action","createPath","UNSAFE_invariant","invariant","createLocation","getHistoryState","PopStateEventType","getUrlBasedHistory","getLocation","createHref","validateLocation","options","window","document","defaultView","v5Compat","globalHistory","history","action","Pop","listener","index","getIndex","replaceState","state","idx","handlePop","nextIndex","delta","location","push","to","Push","historyState","url","pushState","error","DOMException","name","assign","replace","Replace","createURL","base","origin","href","URL","listen","fn","Error","addEventListener","removeEventListener","encodeLocation","pathname","search","hash","go","n"],"sources":["C:\\Users\\nasti\\Desktop\\VK\\ForestEm\\Forest\\node_modules\\@vkontakte\\vk-mini-apps-router\\src\\utils\\react-router-override\\getUrlBasedHistory.ts"],"sourcesContent":["import {\n  Action,\n  createPath,\n  History,\n  Location,\n  To,\n  UNSAFE_invariant as invariant,\n} from '@remix-run/router';\nimport { UrlHistoryOptions } from './UrlHistoryOptions.type';\nimport { Listener } from '@remix-run/router/dist/history';\nimport { createLocation } from './createLocation';\nimport { getHistoryState } from './getHistoryState';\n\nconst PopStateEventType = 'popstate';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nexport function getUrlBasedHistory(\n  getLocation: (window: Window, globalHistory: Window['history']) => Location,\n  createHref: (window: Window, to: To) => string,\n  validateLocation: ((location: Readonly<Location>, to: To) => void) | null,\n  options: UrlHistoryOptions = {}\n): History {\n  const { window = document.defaultView!, v5Compat = false } = options;\n  const globalHistory = window.history;\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  let index = getIndex()!;\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, '');\n  }\n\n  function getIndex(): number {\n    const state = globalHistory.state || { idx: null };\n    return state.idx;\n  }\n\n  function handlePop() {\n    action = Action.Pop;\n    const nextIndex = getIndex();\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({ action, location: history.location, delta });\n    }\n  }\n\n  function push(to: To, state?: any) {\n    action = Action.Push;\n    const location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex() + 1;\n    const historyState = getHistoryState(location, index);\n    const url = history.createHref(location);\n\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, '', url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, const that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === 'DataCloneError') {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 1 });\n    }\n  }\n\n  function replace(to: To, state?: any) {\n    action = Action.Replace;\n    const location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex();\n    const historyState = getHistoryState(location, index);\n    const url = history.createHref(location);\n    globalHistory.replaceState(historyState, '', url);\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 0 });\n    }\n  }\n\n  function createURL(to: To): URL {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    const base =\n      window.location.origin !== 'null'\n        ? window.location.origin\n        : window.location.href;\n\n    const href = typeof to === 'string' ? to : createPath(to);\n    invariant(\n      base,\n      `No window.location.(origin|href) available to create URL for href: ${href}`\n    );\n    return new URL(href, base);\n  }\n\n  const history: History = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn: Listener) {\n      if (listener) {\n        throw new Error('A history only accepts one active listener');\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      const url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash,\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    },\n  };\n\n  return history;\n}\n"]},"metadata":{},"sourceType":"module"}